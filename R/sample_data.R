
#' Sample Occurrence Locations from Predicted Niche Outputs
#'
#' Samples occurrence points from predicted niche outputs generated by
#' \code{\link{predict.nicheR_ellipsoid}}. Sampling can be performed using either
#' Mahalanobis distance or suitability values, with options to emphasize
#' niche center, niche edge, or uniform random selection.
#'
#' The function operates on predicted outputs in geographic space (G-space),
#' but sampling weights are determined by environmental suitability or
#' Mahalanobis distance in environmental space (E-space).
#'
#' @details
#' The input \code{suitable_env} must contain prediction outputs from
#' \code{predict()}, including:
#'
#' \itemize{
#'   \item \code{Mahalanobis} (squared Mahalanobis distance), and optionally
#'   \code{Mahalanobis_trunc}
#'   \item \code{suitability}, and optionally \code{suitability_trunc}
#' }
#'
#' Sampling behavior depends on \code{method} and \code{sampling}:
#'
#' \strong{method = "distance"}
#' \itemize{
#'   \item center: favors small Mahalanobis distance (niche core)
#'   \item edge: favors large Mahalanobis distance (near ellipsoid boundary)
#'   \item random: uniform sampling
#' }
#'
#' \strong{method = "probability"}
#' \itemize{
#'   \item center: favors high suitability values
#'   \item edge: favors low suitability values (but still > 0)
#'   \item random: uniform sampling
#' }
#'
#' If truncated layers are available (\code{Mahalanobis_trunc} or
#' \code{suitability_trunc}), sampling is restricted to environmentally suitable
#' cells.
#'
#' Sampling is performed without replacement.
#'
#' @param n_occ Integer. Number of occurrence points to sample.
#' @param suitable_env A \code{terra::SpatRaster} or \code{data.frame}
#'   containing prediction outputs from \code{predict()}.
#'   Must include coordinate columns (\code{x}, \code{y}) or longitude/latitude
#'   variants (e.g., \code{lon}, \code{lat}, \code{longitude}, \code{latitude}).
#' @param sampling Character. One of \code{"random"}, \code{"center"}, or
#'   \code{"edge"}.
#' @param method Character. One of \code{"distance"} or \code{"probability"}.
#' #' @param truncation Logical. If \code{TRUE} (default), sampling is restricted
#'   to environmentally suitable cells when truncated layers
#'   (\code{Mahalanobis_trunc} or \code{suitability_trunc}) are available.
#'   If \code{FALSE}, sampling is performed across all finite prediction values.
#' @param seed Optional integer. If provided, sets the random seed for
#'   reproducibility.
#' @param verbose Logical. If \code{TRUE}, prints progress messages.
#'
#' @return
#' A \code{data.frame} containing sampled geographic coordinates (\code{x}, \code{y}).
#'
#' @examples
#' \dontrun{
#' pred <- predict(ell,
#'                 newdata = bios,
#'                 include_mahalanobis = TRUE,
#'                 include_suitability = TRUE,
#'                 suitability_truncated = TRUE)
#'
#' occ <- sample_data(n_occ = 100,
#'                    suitable_env = pred,
#'                    sampling = "center",
#'                    method = "probability",
#'                    seed = 42)
#' }
#'
#' @export
sample_data <- function(n_occ,
                        suitable_env,
                        sampling = c("random", "center", "edge"),
                        method = c("distance", "probability"),
                        truncation = TRUE,
                        seed = NULL,
                        verbose = TRUE){

  verbose_message <- function(...) if(isTRUE(verbose)) cat(...)

  sampling <- match.arg(sampling)
  method <- match.arg(method)

  # Basic checks ---------------------------------------------------------------

  if(missing(n_occ) || length(n_occ) != 1 || !is.numeric(n_occ)){
    stop("'n_occ' must be a single numeric value.")
  }

  n_occ <- as.integer(n_occ)

  if(!is.finite(n_occ) || n_occ <= 0){
    stop("'n_occ' must be a positive integer.")
  }

  if(missing(suitable_env) || is.null(suitable_env)){
    stop("'suitable_env' must be provided.")
  }

  if(!is.logical(truncation) || length(truncation) != 1L){
    stop("'truncation' must be TRUE or FALSE.")
  }

  if(!is.null(seed)){
    set.seed(seed)
  }else{
    verbose_message("Sampling seed not set, results will differ each time this function is ran.\n")
  }

  verbose_message("Starting: sampling data...\n")

  # Coerce suitable_env --------------------------------------------------

  if(inherits(suitable_env, "SpatRaster")){
    df <- terra::as.data.frame(suitable_env, xy = TRUE, na.rm = TRUE)
  }else if(is.data.frame(suitable_env)){
    df <- suitable_env
  }else{
    stop("'suitable_env' must be either a SpatRaster or a data.frame.")
  }

  # Coordinate checks ----------------------------------------------------

  if(!all(c("x", "y") %in% names(df))){
    nms_low <- tolower(names(df))

    lon_opts <- c("x", "lon", "long", "longitude", "longitud")
    lat_opts <- c("y", "lat", "latitude", "latitud")
    lon_hit <- intersect(lon_opts, nms_low)
    lat_hit <- intersect(lat_opts, nms_low)

    if(length(lon_hit) > 0 && length(lat_hit) > 0){
      lon_col <- names(df)[match(lon_hit[1], nms_low)]
      lat_col <- names(df)[match(lat_hit[1], nms_low)]

      names(df)[names(df) == lon_col] <- "x"
      names(df)[names(df) == lat_col] <- "y"
    }
  }

  if(!all(c("x", "y") %in% names(df))){
    stop("'suitable_env' must include coordinate columns named x and y (or lon/lat, long/lat, longitude/latitude).")
  }

  # Required predict outputs --------------------------------------------

  has_M  <- "Mahalanobis" %in% names(df)
  has_Mt <- "Mahalanobis_trunc" %in% names(df)
  has_S  <- "suitability" %in% names(df)
  has_St <- "suitability_trunc" %in% names(df)

  if(method == "distance" && !has_M){
    stop("method = 'distance' requires a 'Mahalanobis' column/layer from predict().")
  }

  if(method == "probability" && !has_S && !has_St){
    stop("method = 'probability' requires 'suitability' and/or 'suitability_trunc' from predict().")
  }

  # Candidate filtering --------------------------------------------------

  if(method == "distance"){

    if(truncation && has_Mt){
      df <- df[is.finite(df$Mahalanobis_trunc) &
                 df$Mahalanobis_trunc == 1, , drop = FALSE]
    }else{
      df <- df[is.finite(df$Mahalanobis), , drop = FALSE]
    }
  }

  if(method == "probability"){

    if(truncation && has_St){
      df <- df[is.finite(df$suitability_trunc) &
                 df$suitability_trunc > 0, , drop = FALSE]
    }else{
      df <- df[is.finite(df$suitability), , drop = FALSE]
    }
  }

  if(nrow(df) == 0){
    stop("No candidate rows available for sampling after filtering.")
  }

  if(n_occ > nrow(df)){
    stop("'n_occ' is larger than the number of available candidate rows/cells.")
  }

  # Weights --------------------------------------------------------------

  eps <- 1e-12 # to avoid divisions by zero

  if(sampling == "random"){
    w <- rep(1, nrow(df))
  }

  if(method == "distance"){
    d <- df$Mahalanobis

    if(sampling == "center"){
      w <- 1/(d + eps)
    }

    if(sampling == "edge"){
      w <- d + eps
    }
  }

  if(method == "probability"){
    s <- if(has_St) df$suitability_trunc else df$suitability

    if(sampling == "center"){
      w <- s + eps
    }

    if(sampling == "edge"){
      w <- (1 - s) + eps
    }
  }

  w[!is.finite(w)] <- 0

  if(sum(w) <= 0){
    stop("Sampling weights are all zero. Check your inputs.")
  }

  idx <- sample.int(nrow(df), size = n_occ, replace = FALSE, prob = w)

  out <- df[idx, c("x", "y"), drop = FALSE]

  attr(out, "n_occ") <- nrow(out)
  attr(out, "sampling") <- sampling
  attr(out, "method") <- method
  attr(out, "truncation") <- truncation
  attr(out, "coord_names") <- c("x", "y")

  verbose_message("Done: sampled ", nrow(out), " occurrences.\n")

  out

}



