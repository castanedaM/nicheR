#' Sample Occurrence Locations from Predicted Niche Outputs
#'
#' Samples occurrence points from predicted niche outputs generated by
#' \code{\link{predict.nicheR_ellipsoid}}. Sampling can be performed using either
#' Mahalanobis distance or suitability values, with options to emphasize
#' niche center, niche edge, or uniform random selection.
#'
#' The function operates on predicted outputs in geographic space (G-space),
#' but sampling weights are determined by environmental suitability or
#' Mahalanobis distance in environmental space (E-space).
#'
#' @details
#' The input \code{suitable_env} must contain prediction outputs from
#' \code{predict()}, including:
#'
#' \itemize{
#'   \item \code{Mahalanobis} (squared Mahalanobis distance), and optionally
#'   \code{Mahalanobis_trunc}
#'   \item \code{suitability}, and optionally \code{suitability_trunc}
#' }
#'
#' Sampling behavior depends on \code{method} and \code{sampling}:
#'
#' \strong{method = "distance"}
#' \itemize{
#'   \item center: favors small Mahalanobis distance (niche core)
#'   \item edge: favors large Mahalanobis distance (near ellipsoid boundary)
#'   \item random: uniform sampling
#' }
#'
#' \strong{method = "suitability"}
#' \itemize{
#'   \item center: favors high suitability values
#'   \item edge: favors low suitability values (but still > 0)
#'   \item random: uniform sampling
#' }
#'
#' @param n_occ Integer. Number of occurrence points to sample.
#' @param suitable_env A \code{terra::SpatRaster} or \code{data.frame}
#'   containing prediction outputs from \code{predict()}.
#'   Must include coordinate columns (\code{x}, \code{y}) or longitude/latitude
#'   variants (e.g., \code{lon}, \code{lat}, \code{longitude}, \code{latitude}).
#' @param sampling Character. One of \code{"random"}, \code{"center"}, or
#'   \code{"edge"}.
#' @param method Character. One of \code{"distance"} or \code{"suitability"}.
#' @param truncated Logical. If \code{TRUE} (default), sampling is restricted
#'   to environmentally suitable cells when truncated layers
#'   (\code{Mahalanobis_trunc} or \code{suitability_trunc}) are available.
#'   If \code{FALSE}, sampling is performed across all finite prediction values.
#' @param bias_surface Optional. A \code{SpatRaster} or a list of
#'   \code{SpatRaster} objects used to weight sampling probabilities. When
#'   provided, bias layers are processed with \code{\link{apply_bias}} and the
#'   pooled bias surface is multiplied with the sampling weights.
#' @param bias_dir Numeric vector of \code{1} (use layer as-is) or \code{-1}
#'   (invert via \eqn{1 - x}). A single value is recycled to match the number of
#'   bias layers.
#' @param seed Optional integer. If provided, sets the random seed for
#'   reproducibility.
#' @param verbose Logical. If \code{TRUE}, prints progress messages.
#'
#' @return
#' A \code{data.frame} containing sampled geographic coordinates (\code{x}, \code{y}).
#' The returned object also includes attributes describing the sampling run:
#' \code{n_occ}, \code{sampling}, \code{method}, \code{truncated}, and
#' \code{coord_names}.
#'
#' @examples
#' \dontrun{
#' pred <- predict(ell,
#'                 newdata = bios,
#'                 include_mahalanobis = TRUE,
#'                 include_suitability = TRUE,
#'                 suitability_truncated = TRUE)
#'
#' occ <- sample_data(n_occ = 100,
#'                    suitable_env = pred,
#'                    sampling = "center",
#'                    method = "suitability",
#'                    seed = 42)
#' }
#'
#' @seealso
#' \code{\link{predict.nicheR_ellipsoid}},
#' \code{\link{apply_bias}}
#'
#' @export
sample_data <- function(n_occ,
                        # ellipsoid object
                        # prediction suitable_env,
                        # TO DO: inverse = TRUE/FALSE
                        method = c("distance", "suitability"),
                        truncated = TRUE,
                        bias_surface = NULL,
                        bias_dir = 1,
                        seed = NULL,
                        verbose = TRUE,
                        sampling_mask = NULL){
# TO DO: truncated checks
  verbose_message <- function(...) if(isTRUE(verbose)) cat(...)

  sampling <- match.arg(sampling)
  method <- match.arg(method)

  # Basic checks ---------------------------------------------------------------

  if(missing(n_occ) || length(n_occ) != 1 || !is.numeric(n_occ)){
    stop("'n_occ' must be a single numeric value.")
  }

  n_occ <- as.integer(n_occ)

  if(!is.finite(n_occ) || n_occ <= 0){
    stop("'n_occ' must be a positive integer.")
  }

  if(missing(suitable_env) || is.null(suitable_env)){
    stop("'suitable_env' must be provided.")
  }

  if(!is.logical(truncated) || length(truncated) != 1L){
    stop("'truncated' must be TRUE or FALSE.")
  }

  if(!is.null(seed)){
    set.seed(seed)
  }else{
    verbose_message("Sampling seed not set, results will differ each time this function is ran.\n")
  }

  if(!is.null(bias_surface)){
    if(!inherits(bias_surface, c("SpatRaster", "list"))){
      stop("'bias_surface' must be a SpatRaster or a list of SpatRasters.")
    }
  }

  verbose_message("Starting: sampling data...\n")

  # Coerce suitable_env --------------------------------------------------

  if(inherits(suitable_env, "SpatRaster")){
    df <- terra::as.data.frame(suitable_env, xy = TRUE, na.rm = TRUE)
  }else if(is.data.frame(suitable_env)){
    df <- suitable_env
  }else{
    stop("'suitable_env' must be either a SpatRaster or a data.frame.")
  }

  # Coordinate checks ----------------------------------------------------

  if(!all(c("x", "y") %in% names(df))){
    nms_low <- tolower(names(df))

    lon_opts <- c("x", "lon", "long", "longitude", "longitud")
    lat_opts <- c("y", "lat", "latitude", "latitud")
    lon_hit <- intersect(lon_opts, nms_low)
    lat_hit <- intersect(lat_opts, nms_low)

    if(length(lon_hit) > 0 && length(lat_hit) > 0){
      lon_col <- names(df)[match(lon_hit[1], nms_low)]
      lat_col <- names(df)[match(lat_hit[1], nms_low)]

      names(df)[names(df) == lon_col] <- "x"
      names(df)[names(df) == lat_col] <- "y"
    }
  }

  if(!all(c("x", "y") %in% names(df))){
    stop("'suitable_env' must include coordinate columns named x and y (or lon/lat, long/lat, longitude/latitude).")
  }

  # Required predict outputs --------------------------------------------

  has_M  <- "Mahalanobis" %in% names(df)
  has_Mt <- "Mahalanobis_trunc" %in% names(df)
  has_S  <- "suitability" %in% names(df)
  has_St <- "suitability_trunc" %in% names(df)

  if(method == "distance" && !has_M){
    stop("method = 'distance' requires a 'Mahalanobis' column/layer from predict().")
  }

  if(method == "suitability" && !has_S && !has_St){
    stop("method = 'suitability' requires 'suitability' and/or 'suitability_trunc' from predict().")
  }

  # Candidate filtering --------------------------------------------------

  if(method == "distance"){

    if(truncated && has_Mt){
      df <- df[is.finite(df$Mahalanobis_trunc) &
                 df$Mahalanobis_trunc == 1, , drop = FALSE]
    }else{
      df <- df[is.finite(df$Mahalanobis), , drop = FALSE]
    }
  }

  if(method == "suitability"){

    if(truncated && has_St){
      df <- df[is.finite(df$suitability_trunc) &
                 df$suitability_trunc > 0, , drop = FALSE]
    }else{
      df <- df[is.finite(df$suitability), , drop = FALSE]
    }
  }

  if(nrow(df) == 0){
    stop("No candidate rows available for sampling after filtering.")
  }

  if(n_occ > nrow(df)){
    stop("'n_occ' is larger than the number of available candidate rows/cells.")
  }

  # Weights --------------------------------------------------------------

  eps <- 1e-12 # to avoid divisions by zero

  if(sampling == "random"){
    w <- rep(1, nrow(df))
  }

  if(method == "distance"){
    d <- df$Mahalanobis

    if(sampling == "center"){
      w <- 1/(d + eps)
    }

    if(sampling == "edge"){
      w <- d + eps
    }
  }

  if(method == "suitability"){
    s <- if(has_St) df$suitability_trunc else df$suitability

    if(sampling == "center"){
      w <- s + eps
    }

    if(sampling == "edge"){
      w <- (1 - s) + eps
    }
  }


  # Optional: apply bias ---------------------------------------------------

  if(!is.null(bias_surface)){

    verbose_message("Step: applying bias surface weights...\n")

    bias_obj <- apply_bias(bias_surface = bias_surface,
                           bias_dir = bias_dir,
                           suitable_env = suitable_env,
                           out_bias = "biased",
                           verbose = FALSE,
                           truncated = truncated)

    pooled_bias <- bias_obj$pooled_bias_sp

    # Extract pooled bias values for candidate rows
    b <- terra::extract(pooled_bias, df[, c("x", "y"), drop = FALSE])[, 2]

    b[!is.finite(b)] <- 0
    b[b < 0] <- 0

    w <- w * b
  }


  w[!is.finite(w)] <- 0

  if(sum(w) <= 0){
    stop("Sampling weights are all zero. Check your inputs.")
  }

  idx <- sample.int(nrow(df), size = n_occ, replace = FALSE, prob = w)

  out <- df[idx, c("x", "y"), drop = FALSE]

  attr(out, "n_occ") <- nrow(out)
  attr(out, "sampling") <- sampling
  attr(out, "method") <- method
  attr(out, "truncated") <- truncated
  attr(out, "coord_names") <- c("x", "y")

  verbose_message("Done: sampled ", nrow(out), " occurrences.\n")

  out

}



